  <?php $userFile = $_COOKIE['Userfile']; ?>
  <div style="width: 100%; height: 800px;">
    <div id="chart1" style="width: 50%; height: 50%; float: left;" ></div>
    <div id="chart2" style="margin-left: 50%; height: 50%;"></div>
    <div id="chart3" style="width: 100%; height: 50%;">
      <table id="tableSequence" style="width: 100%; height: 100%;">
        <thead>
          <tr>
            <th width=10%>Name</th>
            <th>Sequence</th>
          </tr>
        </thead>
      </table>
    </div>
  </div>

  <script>
    var clone = localStorage['clone'];
    //localStorage.removeItem( 'clonotypeData' ); // Clear the localStorage
    var selectedNode = [];

//****************** Tree
    //loading the json file
d3.json("pipeline/usersFiles/example/example_"+clone+"_clonotype.json", function(error, dataTree) {
  if (error) throw error;

    var data = d3.hierarchy(dataTree); //data structure that represente a hieratchy
    changeDepth(data);

    //store the most abundant clonotypes
    var distanceOfClonotypes = [];
    findMostAbundantClonotypes(data, distanceOfClonotypes);
    //retrieve the name of all the clonotypes selected
    var clonotypesName = distanceOfClonotypes.map(function(d){ return d.data.name });
    
    distancesRepresentation(distanceOfClonotypes);

    //create the table of the sequences
    displaySequence(data.children);

    // set the dimensions and margins of the diagram
    var margin = {top: 20, right: 10, bottom: 20, left: 10},
        width = (document.getElementById('chart1').offsetWidth)-1 - margin.left - margin.right,	//get width of chart2 element in px 
        height = (document.getElementById('chart1').offsetHeight)- margin.top - margin.bottom;

    // append the svg object to the body of the page
      // appends a 'group' element to 'svg'
      // moves the 'group' element to the top left margin
      var svg1 = d3.select("#chart1").append("svg")
             .attr("width", width + margin.left + margin.right)
             .attr("height", height + margin.top + margin.bottom)
          .append("g")
           .attr("transform", "translate(" + width/2 +','+ height/2 + ")");

      // declares a tree layout and assigns the size
      var tree = d3.tree()	//creating the tree layout 
             // .nodeSize([10,80])
              //.size([height, width])
              //.separation(function(a, b) { return ((a.depth >= 2) && (b.depth >= 2)) ? 1 : 4; });
              //.separation(function(a, b) { return ((a.parent == data) && (b.parent == data)) ? 5 : 1; });
.size([2 * Math.PI, height/2])
//.separation(function(a, b) { return ((a.parent == data) && (b.parent == data)) ? 3 : 1; });
.separation(function(a, b) { return ((a.depth >= 2) && (b.depth >= 2)) ? 1 : 4; });
              
      var duration = 750;
      data.x0 = height / 2;
      data.y0 = 0;

      //data.children.forEach(collapse);

      updateTree(data);

      function updateTree(source){

        //assign properties to the data (coordinates, depth, ...)
        var root = tree(data);

        //adjust the length of the branch depending on the radius of the node and the position between the nodes
        //branchLength(root);

        // ********* Creation of the nodes *********

        //add each node as a group
        var node = svg1.selectAll("g")
                .data(root.descendants());

        var nodeEnter = node.enter().append("g")
                     .attr("transform", function(d) { return "translate(" + radialPoint(source.x0, source.y0) + ")";})	//position the nodes
                     .on('click', selectClonotype)
                     .on('dblclick', changeChildren);

        // adds the circle to the node
        nodeEnter.append("circle")
                 .style("fill", function(d){ return d.data.color; })
        .style("stroke", function(d){ return d.data.stroke; })
        .style("stroke-dasharray", function(d){ return d.data.style; })
        .style("stroke-width", 1)
                 .attr("r", function(d) { return d.data.value? 2*d.data.value : 0}); //set the diameter of the node

        //add text to the node
        nodeEnter.append("text")
                 .attr('font-size', 11) //set the size of the text
                 .attr("dy", function(d) { return 15+(2*d.data.value)})	//set the emplacement of the text
                 .attr("dx", 15)
                 .attr("text-anchor", "middle")
                 .text(function(d) { if(d.data.name!="naive"){return d.data.name;}})
                 .clone(true).lower()
                 .attr("stroke", "white");

       //display the clone selected
       nodeEnter.filter(function (d, i) { if(clonotypesName.indexOf(d.data.name)!=-1){ selectedNode.push(d); return d.data.name; }})
                .style("font-weight", "bold")
                .classed("selected",true)
                .selectAll("circle").style("stroke-width", 3);

        var nodeUpdate = nodeEnter.merge(node);

        //transition to the proper position for the node
        nodeUpdate.transition()
                  .duration(duration)
                  .attr("transform", function(d) { return "translate(" + radialPoint(d.x, d.y) + ")";});

        nodeUpdate.select('circle')
                  .attr('r', function(d) { return d.data.value? 2*d.data.value : 2})
                  
                  .attr('cursor', 'pointer');

        //remove any exiting nodes
        var nodeExit = node.exit().transition()
                    .duration(duration)
                    .attr("transform", function(d) { return "translate(" + radialPoint(source.x, source.y) + ")";})
                    .remove();

        // ********* Creation of links *********

        //add the links between the nodes
        var link = svg1.selectAll("path")
                .data(root.descendants().slice(1));
              
        var linkEnter = link.enter().insert('path',"g")	//SVG path allow to draw shape
              .attr("fill", "none")
              .attr("stroke", "#555")
              .attr("stroke-opacity", 0.5)
              .attr("stroke-width", 2)
                     .attr("d", function(d){ var s = {x : source.x0, y : source.y0}; return branchShape(source, source);});

        //update link
        var linkUpdate = linkEnter.merge(link);

        //transition back to the parent element position
        linkUpdate.transition()
                  .duration(duration)
                  .attr("d", function(d){ return branchShape(d, d.parent); });

        //remove any exiting links
        var linkExit = link.exit().transition()
                    .duration(duration)
                    .attr("d", function(d){ var s = {x : source.x, y : source.y}; return branchShape(s, s);})
                    .remove();

        root.descendants().forEach(function(d){ d.x0 = d.x; d.y0 = d.y;});

      }

      function changeChildren(d){
        if(d.children){
          d._children = d.children;
          d.children = null;
        }else{
          d.children = d._children;
          d._children = null;
        }
        updateTree(d);
      }


      //action performes when nodes are selected or deselected
      function selectClonotype(d){
        if (!d3.select(this).classed("selected")) {
          if(selectedNode.length>8){
            alert("Can't show the distance of more than 8 clonotypes")
          }else{
            selectedNode.push(d); //add the clonotype selected in the array containing all the element selected
            d3.select(this)	//change the style of the selected clonotype
              .style("font-weight", "bold")
              .classed("selected",true)
            d3.select(this).selectAll("circle")
                .style("stroke-width", 3);
          }
        }else{
          index = selectedNode.indexOf(d);
          d3.select(this)	//change the style of the deselected clonotype
            .style("font-weight", "normal")
            .classed("selected",false);
          d3.select(this).selectAll("circle")
              .style("stroke-width", 1);
          selectedNode.splice(index,1) 	//delete the clonotype from the array with all the selected element 
          //if(selectedNode!=[]){displaySequence(data, ["Name", "Sequence"],["name","seq"]);}
        }
        d3.select("#chart2 svg").remove();
        distancesRepresentation(selectedNode);
      }
});
      function radialPoint(x, y) {
	return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
      }

      function changeDepth(d){
        for(var i in d.children){ d.children[i].depth = d.depth+(1*d.children[i].data["length"]);
        if (d.children[i].children){changeDepth(d.children[i]);}}
      }

      //**************************************** distance ****************************************************

  //create the representation of the distances
  function distancesRepresentation(distanceOfClonotypes){

      var distanceTable = [] //store the clonotypes for which the distance will be represented on the chart
      //retrieve the name of all the clonotypes selected
      var clonotypesName = distanceOfClonotypes.map(function(d){ return d.data.name });
      createDistanceTable(distanceTable, distanceOfClonotypes); //table of the distance of the 5 most abundant clonotypes that'll be use in the graph representing the distance

      //margin = {top: 50, right: 10, bottom: 50, left: 100};
      width = (document.getElementById('chart2').offsetWidth );	//get width of chart2 element in px 
      height = (document.getElementById('chart2').offsetHeight );
      chartRadius = height / 2 - 25;

var svg = d3.select('#chart2').append('svg')
  .attr('width', width)
  .attr('height', height)
  .append('g')
    .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

var tooltip = d3.select('#chart2').append('div')
  .attr('class', 'tooltip');

var pi = Math.PI,
  arcPosition = 50,	//position of the arc relative to the center
  arcPadding = 10;	//space between the different arcs

  var maxDistance = d3.max(distanceTable, function(d){ return d.length });
  //create a quantitative linear scale. This function map data values into visual variables
  var scale = d3.scaleLinear()
    .domain([0, maxDistance * 1.33])	//minimum and maximum values of the input data (the min and max distance between clonotype)
    .range([0, 2 * pi]); //range of values to which the distance values match

  //array of values sampled from the scaleâ€™s domain
  var ticks = scale.ticks(maxDistance);

  //number of clonotypes
  var numClonotypes = clonotypesName.length;
  //calculation of the width of the arcs according to the number of clonotypes
  var arcWidth = (chartRadius - arcPosition - numClonotypes * arcPadding) / numClonotypes;

//create a new arc generator
  var arc = d3.arc()
         .innerRadius(function(d, i){ return getInnerRadius(parseInt(distanceTable[i].index)); }) //set the inner radius to a specific value determine by a function
         .outerRadius(function(d, i){ return getOuterRadius(parseInt(distanceTable[i].index)); })
         .startAngle(function(d, i){ return scale(parseInt(distanceTable[i].start)); })	//determine the start angle for the arcs
         .endAngle(function(d){ return scale(d); });	//end angle of the cercle determine by the scale function

  //create radial axis to add text to identify the different axes
  var radialAxis = svg.append('g')
    .selectAll('g')
      .data(distanceTable)
      .enter().append('g');

  radialAxis.append('text')
    .style('font', '12px sans-serif')
    .attr('x', -45)
    .attr('y', function(d, i){ return (-getOuterRadius(i) + arcPadding); })
    .text(function(d,i){ return clonotypesName[i]; });

  //create axial axis to identify the distances
  var axialAxis = svg.append('g')
    .selectAll('g')
      .data(ticks)
      .enter().append('g')
        .attr('transform', function(d) { return 'rotate(' + ((scale(d) * 180 / pi) - 90) + ')'; });

  //add line to the axial axis
  axialAxis.append('line')
    .style("stroke", "#cccccc")
    .style("stroke-width", "1px")
    .attr('x2', chartRadius);

  axialAxis.append('text')
    .attr('x', chartRadius + 10)
    .style('font', '12px sans-serif')
    .style('text-anchor', function (d) { return (scale(d) >= pi && scale(d) < 2 * pi ? 'end' : null); })
    .attr('transform', function (d) { return 'rotate(' + (90 - (scale(d) * 180 / pi)) + ',' + (chartRadius + 10) + ',0)'; })
    .text(function(d){ return d; });

  //data arcs
  var arcs = svg.append('g')
    //.attr('class', 'data')
    .selectAll('path')
      .data(distanceTable)
      .enter().append('path')
      //.attr('class', 'arc')
      .style('fill', function(d, i) { return d.color; } )
      .style("stroke", function(d){ return d.stroke; })
        .style("stroke-dasharray", function(d){ return d.style; })
        .style("stroke-width", 0.75)

  arcs.transition()
    .delay(function(d, i) { return i * 200; } )
    .duration(750)
    .attrTween('d', arcTween);

  //arcs.on('mousemove', showTooltip)
  //arcs.on('mouseout', hideTooltip)

  function arcTween(d, i) {
    var interpolate = d3.interpolate(0, d.length);
    return t => arc(interpolate(t), i);
  }

  /*function showTooltip(d) {
    tooltip.style('left', (d3.event.pageX + 10) + 'px')
      .style('top', (d3.event.pageY - 25) + 'px')
      .style('display', 'inline-block')
      .html(d.value);
  }

  function hideTooltip() {
    tooltip.style('display', 'none');
  }*/

  //calculate the value of inner radius in function of the index of the clonotype
  function getInnerRadius(index) {
    return arcPosition + (numClonotypes - (index + 1)) * (arcWidth + arcPadding); //the position of the inner radius corresponds to the addition of distance from the center and the thickness of the other arcs according to the clonotype index
  }

  //calculate the value of outer radius in function of the index of the clonotype
  function getOuterRadius(index) {
    return getInnerRadius(index) + arcWidth; //the position of the outer radius correpond to the addition of the position of the inner radius and the tickness of the arc
  }
}

//browse the tree of clonotypes to find the 5 first clonotypes with the most abundance
function findMostAbundantClonotypes(node, table){
  //for each children of the given node 
  for(var i in node.children){
    //there is already 5 clonotypes stores in the tab
    if(table.length == 5){
      //Compare the abundance of the clonotypes to those in of the clonotypes in the tab
      comparisonOfAbundance(table, node.children[i]);
    }else{
      //add the clonotypes to the table
      table.push(node.children[i]);
      //sort the elment of the table depending on the abundance
      table.sort(function sortByAbondance(a, b){
        if (a.data.value < b.data.value){
          return -1;
        }else if (a.data.value > b.data.value){
          return 1;
        }
        return 0;
      });
      table.reverse();
    }
    //look among the children of this node if there are clonotypes with more abundance
    if(node.children[i].children){ findMostAbundantClonotypes(node.children[i], table); }
  }
}

//modify the table that store the most abundant clonotypes if clonotypewith a abundance superior is found
function comparisonOfAbundance(table, clonotype){
  var nbElement = table.length; 
  var superior = true;
  var indice = -1;
  //browse all the element of the table to find if the clonotype has an abindance superior to the other
  while( superior && (nbElement != 0)){
    if(parseFloat(clonotype.data.value)>table[nbElement-1].data.value){
      indice = nbElement-1; //store the position of the element 
    }else{
      superior=false;
    }
    nbElement--;
  }
  //modify the table if the clonotype have a abundance superior to the clonotype of the table
  if(indice!=-1){
    table.splice(indice, 0, clonotype); //add the clonotype to the table
    table.pop(); //delete the last element of the table
  }
}

//create an array which contain the five clonotpes with the most abundance to allow to draw the chart
function createDistanceTable(table, clonotypes){
  //browse the table containing the clonotype to represent
  for(var i in clonotypes){
    parentsLength = storeClonotypesAncestor(table, clonotypes[i], i, clonotypes[i].data.name);
  }
}

//browse all the parent of clonotype to add them to the array it is necessary to represent the distance
function storeClonotypesAncestor(table, clonotype, index, name){
  //browse in the parent of the clonotype
  if(clonotype.parent){
    parentsLength = storeClonotypesAncestor(table, clonotype.parent, index, name);
    //allow to know which name should be write on the graph
    if(name==clonotype.data["name"]){ appear=true; }else{ appear=false; }
    //cumulate the length of the parent to allow to draw the distances on the graph
    length = parseFloat(clonotype.data["length"])+parentsLength
    table.push({"name":clonotype.data["name"], "value":clonotype.data["value"], "length":length, "color":clonotype.data["color"], "index":index, "start":parentsLength, "stroke":clonotype.data["stroke"], "style":clonotype.data["style"]}); //add the clonotype to the table of clonotype
    return length;
  }else{
    return 0;
  }  
}

// Add title to graph
/*svg2.append("text")
        .attr("x", 0)
        .attr("y", -20)
        .attr("text-anchor", "left")
        .style("font-size", "14px")
        .text("Heatmap of distances between clonotypes");*/



//********************** Sequence **************************************************************************

  function displaySequence(data){

    //select the div element which will contain the sequences
    var table = document.getElementById('tableSequence');
    
    //create a tbody element and add it to the table
    var tbody = document.createElement('tbody');
    table.appendChild(tbody);

    childClonotypeSequence(data,tbody);

  }
  
    function childClonotypeSequence(data,table){
      //browse the clones and show the sequences for each of them
      for(var i in data){ 
        //create a tr element to add a line and add it to the table
        var tr = document.createElement('tr');
        table.appendChild(tr);
        //create a td element to add a cell that contain the name
        var td1 = document.createElement('td');
        td1.appendChild(document.createTextNode(data[i].data["name"]));
        td1.style.width = "10%"; 
        //create a td element to add a cell that contain the sequence
        var td2 = document.createElement('td');
        //create a p element which will contain the sequence of the clone or clonotype
        var p = document.createElement('p');
        p.classList = "tableSeqCell";
        p.appendChild(document.createTextNode(data[i].data["seq"]));
        //add it to the td element
        td2.appendChild(p);
        //add all the element created to the table      
        tr.appendChild(td1);
        tr.appendChild(td2);
        if(data[i].children){childClonotypeSequence(data[i].children,table)}
      }
    }


    function collapse(d){
      if(d.children){
        if(d.depth>=2){
          d._children = d.children;
          d._children.forEach(collapse);
          d.children = null;
        }else{
          d.children.forEach(collapse);
        }
      }
    }

    //give the start and end point to a branch    
    function branchShape(s,t) {
      return "M" + radialPoint(s.x, s.y)[0] + "," + radialPoint(s.x, s.y)[1] + " " + radialPoint(t.x, t.y)[0] + "," + radialPoint(t.x, t.y)[1];
    }

    
    function branchLength(nodes){
      //var maxValue = maxClonotypeValue(nodes);
      for(var i in nodes.children){
        coef = (nodes.children[i].x-nodes.x)/(nodes.children[i].y-nodes.y);
        nodes.children[i].y = nodes.children[i].y + ((nodes.y - nodes.children[i].y) * (1-nodes.children[i].data["length"]));   
        nodes.children[i].x = (nodes.children[i].y * coef) + nodes.x;
        if(nodes.children[i].children != undefined){
          branchLength(nodes.children[i]);
        }
      }
    }


    //browse the tree to find the clonotype with the biggest abundance and return its value
    function maxClonotypeValue(data){
      var maxValue = 0;
      for(var i in data.children){
        if(parseFloat(data.children[i].data.value) > maxValue){maxValue = parseFloat(data.children[i].data.value);} 
	//if(data.children[i].children != undefined){maxClonotypeValue(data.children[i], maxValue);}
      }
      return maxValue;
    }

    function variableMat(data, variable, clonotypeAbundance, clonotypeColor){
      for(var i in data.children){
        variable.push(data.children[i].data["name"]);
        clonotypeAbundance[data.children[i].data["name"]]=data.children[i].data["value"];
        clonotypeColor[data.children[i].data["name"]]=data.children[i].data["color"];
        if(data.children[i].children){variableMat(data.children[i], variable, clonotypeAbundance, clonotypeColor);}
      }
    }

    function distanceMat(distanceMatrice){
      d3.csv("distance_clone1.csv", function(distance) {
        for(var i in distance){
          distanceMatrice.push(distance[i]);
          distanceMatrice[distanceMatrice.length-1]["length"]=parseFloat(distanceMatrice[distanceMatrice.length-1]["length"]);
        }
      })
    }

    function distanceClonotype(data, distanceMatrice, variables, ...parents){
      for(var i in data.children){
	variables.push(data.children[i].data["name"]);
        distanceMatrice.push({"name1": data.children[i].parent.data["name"], "name2": data.children[i].data["name"], "length": parseFloat(data.children[i].data["length"])});
        distanceMatrice.push({"name1": data.children[i].data["name"], "name2": data.children[i].parent.data["name"], "length": parseFloat(data.children[i].data["length"])});
        var ancestor = [];
        for(var j in parents){
          length = parents[j]["length"] + parseFloat(data.children[i].data["length"]);
          distanceMatrice.push({"name1": parents[j]["name"], "name2": data.children[i].data["name"], "length": length});
          distanceMatrice.push({"name1": data.children[i].data["name"], "name2": parents[j]["name"], "length": length});
          ancestor.push({"name": parents[j]["name"], "length": length});
        }
        if(data.children[i].children){
          ancestor.push({"name":data.children[i].parent.data["name"], "length": parseFloat(data.children[i].data["length"])});
          distanceClonotype(data.children[i], distanceMatrice, variables, ...ancestor);
        }
      }
    }


  </script>


